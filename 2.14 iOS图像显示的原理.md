# 2.14 iOS图像显示的原理

这篇文章真是看得人老泪纵横呀，内容朴实，我想技术人大多都是这样简单纯粹的人吧。说到这里想到一个朋友，这篇文章就是他发给我的，朋友大概就是那种无关蓝颜红颜也无关性别的在精神甚至在物质上都会支持你的人吧。

[金旭亮：一个普通IT人的十年回顾](http://blog.jobbole.com/12968/)

![屏幕快照 2017-02-14 下午3.11.23](media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%883.11.23.png)

看到这里，想起昨天我的CC老师问我为什么要学英语，我竟无言以对，我说我喜欢学，她的笑容我很难形容，大概是我这个理由太少见吧。为什么一定要出国才考雅思，进外企才学英语，我就是愿意学，爱咋咋地。
拥有电脑成为作者的梦想，然而就在那个年代，父母竟然也给我们买了电脑，现在想想真的无法理解，让我拿出一年的收入买这样一个在当时看来没什么卵用的东西，就是用这台电脑，我学会了打字，学会了一些简单的html，也学会了玩游戏。。然而，今年过年回家用年终奖的一部分，只是一部分，给老爸买了台笔记本，只有我的Mac一半的价钱，他都觉得是浪费，当然，他还是开心的像个孩子。

这里还有一本书，写的太好，以至于我都懒得吃晚饭了。

[未来世界的幸存者](https://ruanyf.github.io/survivor/index.html)

## iOS图像显示的原理

言归正传，研究这一块的起因是项目之前做的一系列关于app流畅滑动的优化，因为列表页加载的图片较多，所以优化起来很繁琐，最主要的工作是逆向了App Store的首页，并且针对每个优化点进行了深挖，当然，这些都是同事做的，我只是拿来学习Orz

> AppStore圆角绘制

![屏幕快照 2017-02-14 上午11.25.18](media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8A%E5%8D%8811.25.18.png)

从这里可以看出，它并没有用到我们平时所说的在layer上设置圆角半径，通过离屏渲染来实现切圆角，而是通过几个图层的叠加来实现的。

这样做的好处是可以提升页面的流畅度，但为何会这样呢？
下面这张图形象的表示了CPU、GPU、FrameBuffer、显示器的关系(此处为盗图)

![屏幕快照 2017-02-14 下午11.12.42](media/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-14%20%E4%B8%8B%E5%8D%8811.12.42.png)

1、 CPU 计算显示内容提交给 GPU ，如：视图的创建、布局计算、图片解码、文本绘制(如产品提的需求)

2、 GPU 渲染后将结果放入 FrameBuffer (如开发将需求完成并提交)

FrameBuffer 中存放的是你在屏幕上看到的所有像素的颜色值和半透明值

3、 视频控制器按照 VSync 读取 FrameBuffer 显示到屏幕上(如将代码打包发布上线)

那么，GPU大哥到底做了些什么呢？我当然想知道，不然怎么做开发？

* 从磁盘拷贝数据到内核缓冲区
* 从内核缓冲区复制数据到用户空间
* 生成UIImageView，把图像数据赋值给UIImageView
* 如果图像数据为未解码的PNG/JPG，解码为位图数据
* CATransaction捕获到UIImageView layer树的变化
* 主线程Runloop提交CATransaction，开始进行图像渲染

	* 如果数据没有字节对齐，Core Animation会再拷贝一份数据，进行字节对齐
	* GPU处理位图数据，进行渲染

离屏渲染在这里成了罪魁祸首，它不仅需要开辟新的缓冲区OffScreenBuffer，还要将渲染的内容合并，进而进行两次昂贵的环境切换，这也是App Store不使用它的原因吧。

综上，我们可以认为，CPU计算、GPU绘制、FrameBuffer存储、VSync发送信号、显示器用来显示，一个图像的显示所经历的过程何其漫长啊，而在GPU绘制的过程中，又存在着离屏渲染这个耗时耗力的操作，当然这只是优化时考虑的一个点而已，尽量避免离屏渲染也成了一个重要工作，虽然一味的追逐fps是没有意义的。


