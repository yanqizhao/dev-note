# 6.12-6.16

马上就要到该写年中总结的时候了，然而我的博客还没有开始写，从3月搭建好之后就各种忙，离职，旅游，找工作，适应工作，搬家，收拾家，转眼就是3个多月了，接下来要开始将这两个多月工作中的内容先总结一下，还有之前的一些面试题，最后，还有WWDC。

这周主要要写的是关于底层api请求模块的设计。

首先，之前关于api请求都只是在用AFN，好像并没有想过要自己写，或者认真的看AFN源码，来这里工作后正好赶上了api层的优化，认真的对比了几个版本的设计后，学到了很多。

关于模块设计的好坏，不止是api请求的模块，都有两个很重要的衡量标准，一个是通用性，另一个是可扩展性。

通用性是指，所有使用你设计出的模块的上层，都能够根据文档平滑无感的使用，无需为了你的设计额外做一些工作，而可扩展性则是，当上层觉得功能不够使用的时候，可以便捷快速的扩展出他们需要的功能。

这里，我们上层的api之前的几个版本都是通过继承底层基类api实现的，这一版本的改动则是先从之前的版本迁移到最新版后，由上层直接使用，不再继承。

在迁移的过程中，出现次数比较多的问题是由于先前版本使用了继承的方式，而上层使用者由于编码不规范，擅自使用底层基类api的私有方法而造成的。因为很多先前版本的私有方法已经被删除，而子类还在使用，就会造成很多功能的缺失。这是使用继承的一个缺点，而不用继承的缺点则是可扩展性降低，为了弥补这个问题，我们设计了很多回调的block，从请求开始前的request，到请求结束后的response，以及缓存内容，都可以由外界自定义。

另一个问题则是先前版本迁移的时候不够彻底，创建过一些中间过渡类，并且作为代理存在在两个版本之间，而我们通常都使用weak作为代理的属性修饰，而api请求大多都是异步的，通过回调来使用返回的数据，这里很多异步请求还没返回数据时，中间过渡类其实已经被销毁了，所以我们将其属性改为了strong。

这就是我在api请求模块迁移的过程中遇到过的一些问题，具体的设计会在阅读AFN源码对比之后再来写。

